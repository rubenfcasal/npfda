% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/np.var.npf.R
\name{np.var}
\alias{np.var}
\alias{npf.var-class}
\alias{npf.var}
\alias{np.var.npf.locpol}
\alias{np.var.npf.bin.res2}
\alias{predict.npf.var}
\title{Local polynomial variance estimation}
\usage{
np.var(x, ...)

\method{np.var}{npf.locpol}(
  x,
  h = NULL,
  degree = 1 + as.numeric(drv),
  drv = FALSE,
  hat.bin = FALSE,
  ncv = 0,
  ...
)

\method{np.var}{npf.bin.res2}(
  x,
  h = NULL,
  degree = 1 + as.numeric(drv),
  drv = FALSE,
  hat.bin = FALSE,
  ncv = 0,
  ...
)

\method{predict}{npf.var}(object, newx = NULL, ...)
}
\arguments{
\item{x}{an object used to select a method.}

\item{...}{further arguments passed to or from other methods.}

\item{h}{(full) bandwidth matrix (controls the degree of smoothing;
only the upper triangular part of h is used).}

\item{degree}{degree of the local polynomial used. Defaults to 1 (local linear estimation).}

\item{drv}{logical; if \code{TRUE}, the matrix of estimated first derivatives is returned.}

\item{hat.bin}{logical; if \code{TRUE}, the hat matrix of the binned data is returned.}

\item{ncv}{integer; determines the number of cells leaved out in each dimension.
Defaults to 0 (the full data is used) and it is not normally changed by the user
in this setting. See "Details" below.}

\item{object}{object used to select a method.}

\item{newx}{vector with the (irregular) points to predict (interpolate).}
}
\value{
Returns an S3 object of class \code{npf.var} extending \code{\link[npsp:locpol]{npsp::locpol.bin}}
(locpol + bin data + grid par.).

If \code{newx == NULL}, \code{predict.npf.var} returns the variance estimates
corresponding to the discretization points
(otherwise \code{npsp::interp.data.grid} is called).
}
\description{
Estimates the functional variance (and its first derivatives)
using local polynomial kernel smoothing.
}
\examples{
fd <- npf.data(ozone, dimnames = "day")
# Linear Local trend estimate
lp <- locpol(fd, h = 35)
# Linear Local variance estimate
lp.var <- np.var(lp, h = 50)
# Plot data + estimated trend -+ estimated std. dev.
plot(lp$data, col = "lightgray", legend = FALSE)
x <- lp$data$x
y <- lp$est
lines(x, y)
matlines(x, y + sqrt(lp.var$est) \%o\% c(-1, 1), col = 1, lty = 2)
# Bandwidth selection (assuming independence)
bin.res2 <- npf.bin.res2(lp)
var.h <- h.cv(bin.res2)$h
# the selected bandwidth undersmoothes the squared residuals...
var.h <- 7*var.h
# Linear Local variance estimate
lp.var <- np.var(lp, h = var.h)
# Plot data + estimated trend -+ estimated std. dev.
plot(lp$data, col = "lightgray", legend = FALSE)
x <- lp$data$x
y <- lp$est
lines(x, y)
matlines(x, y + sqrt(lp.var$est) \%o\% c(-1, 1), col = 1, lty = 2)
}
\seealso{
\code{\link{npf.bin.res2}}
}
